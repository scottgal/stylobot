@* Bot Ticker - Real-time detection feed using SignalR + Alpine.js + HTMX *@
@{
    var hubPath = "/_stylobot/hub";
    var cspNonce = ViewContext.HttpContext.Items["CspNonce"]?.ToString() ?? string.Empty;
}

<div class="stylobot-ticker"
     x-data="botTicker()"
     x-init="connect()"
     x-cloak>

    <!-- Ticker Bar -->
    <div class="ticker-bar">
        <div class="ticker-label">
            <span class="ticker-icon">R</span>
            <span>LIVE</span>
        </div>

        <!-- Scrolling detections -->
        <div class="ticker-scroll" x-ref="tickerScroll">
            <template x-for="(detection, idx) in detections" :key="detection._id || idx">
                <a class="ticker-item"
                   :href="'/dashboard/signature/' + encodeURIComponent(detection.primarySignature || '')"
                   :class="{ 'is-bot': detection.isBot, 'ticker-item-new': detection._isNew }">
                    <span class="ticker-item-icon" x-text="detection.isBot ? 'R' : 'H'"></span>
                    <span class="ticker-item-risk"
                          :class="'risk-' + (detection.riskBand || '').toLowerCase()"
                          x-text="detection.riskBand || '-'"></span>
                    <template x-if="detection.botName">
                        <span class="ticker-item-botname" x-text="detection.botName"></span>
                    </template>
                    <template x-if="detection.botType && !detection.botName">
                        <span class="ticker-item-botname" x-text="detection.botType"></span>
                    </template>
                    <span class="ticker-item-path" x-text="(detection.path || '').length > 20 ? (detection.path || '').substring(0, 17) + '...' : (detection.path || '')"></span>
                    <span class="ticker-item-prob" x-text="Math.round((detection.botProbability || 0) * 100) + '%'"></span>
                    <span class="ticker-item-time" x-text="formatTime(detection.timestamp)"></span>
                </a>
            </template>

            <!-- Empty state -->
            <template x-if="detections.length === 0 && connected">
                <span class="ticker-empty">Waiting for detections...</span>
            </template>

            <!-- Connecting state -->
            <template x-if="!connected">
                <span class="ticker-connecting">Connecting to live feed...</span>
            </template>
        </div>

        <!-- Stats summary -->
        <div class="ticker-stats" x-show="summary">
            <span class="stat-item">
                <span class="stat-label">Total:</span>
                <span class="stat-value" x-text="summary?.totalRequests || 0"></span>
            </span>
            <span class="stat-item stat-bot">
                <span class="stat-label">Bots:</span>
                <span class="stat-value" x-text="summary?.botRequests || 0"></span>
            </span>
            <span class="stat-item stat-human">
                <span class="stat-label">Humans:</span>
                <span class="stat-value" x-text="summary?.humanRequests || 0"></span>
            </span>
        </div>

        <!-- Dashboard link -->
        <a href="/dashboard" class="ticker-dashboard-link" title="Open Dashboard">
            Dashboard
        </a>
    </div>
</div>

<script nonce="@cspNonce">
document.addEventListener('alpine:init', () => {
    // Normalize PascalCase API keys to camelCase
    function toCamel(obj) {
        if (Array.isArray(obj)) return obj.map(toCamel);
        if (obj !== null && typeof obj === 'object') {
            return Object.fromEntries(
                Object.entries(obj).map(([k, v]) => [k.charAt(0).toLowerCase() + k.slice(1), toCamel(v)])
            );
        }
        return obj;
    }

    let tickerId = 0;

    Alpine.data('botTicker', () => ({
        connected: false,
        detections: [],
        summary: null,
        connection: null,
        maxDetections: 20,

        async connect() {
            try {
                // Load SignalR if not already loaded
                if (typeof signalR === 'undefined') {
                    await this.loadSignalR();
                }

                this.connection = new signalR.HubConnectionBuilder()
                    .withUrl('@hubPath')
                    .withAutomaticReconnect([0, 2000, 5000, 10000, 30000])
                    .configureLogging(signalR.LogLevel.Warning)
                    .build();

                // Handle detection events
                this.connection.on('BroadcastDetection', (raw) => {
                    this.addDetection(toCamel(raw));
                });

                // Handle signature events
                this.connection.on('BroadcastSignature', (raw) => {
                    // Could highlight in ticker
                });

                // Handle summary updates
                this.connection.on('BroadcastSummary', (raw) => {
                    this.summary = toCamel(raw);
                });

                // Connection state handlers
                this.connection.onclose(() => { this.connected = false; });
                this.connection.onreconnecting(() => { this.connected = false; });
                this.connection.onreconnected(() => { this.connected = true; });

                await this.connection.start();
                this.connected = true;

            } catch (error) {
                console.error('[BotTicker] Connection failed:', error);
                this.connected = false;
            }
        },

        async loadSignalR() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@@microsoft/signalr@@8.0.0/dist/browser/signalr.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        },

        addDetection(detection) {
            // Only show interesting detections: bots OR medium+ risk
            const dominated = detection.isBot ||
                              (detection.botProbability || 0) >= 0.4 ||
                              ['Medium', 'High', 'VeryHigh'].includes(detection.riskBand);

            if (!dominated) return;

            // Add to front with unique ID and new-entry animation flag
            this.detections.unshift({
                ...detection,
                _id: ++tickerId,
                _isNew: true,
                timestamp: detection.timestamp ? new Date(detection.timestamp) : new Date()
            });

            // Remove new animation class after transition
            setTimeout(() => {
                const d = this.detections.find(d => d._id === tickerId);
                if (d) d._isNew = false;
            }, 600);

            // Keep only recent detections
            if (this.detections.length > this.maxDetections) {
                this.detections = this.detections.slice(0, this.maxDetections);
            }
        },

        formatTime(timestamp) {
            if (!timestamp) return '';
            const d = new Date(timestamp);
            if (isNaN(d.getTime())) return '';
            return d.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
    }));
});
</script>
